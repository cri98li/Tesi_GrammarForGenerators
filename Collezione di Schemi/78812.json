{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","additionalProperties":false,"title":"dependency-cruiser output format","type":"object","definitions":{"_88SummaryType":{"description":"Data summarizing the found dependencies","additionalProperties":false,"type":"object","properties":{"___optionsUsed":{"$eref":{"description":"the (command line) options used to generate the dependency-tree","additionalProperties":false,"type":"object","properties":{"___doNotFollow":{"$ref":"#\/definitions\/CompoundDoNotFollowType"},"___outputType":{"$ref":"#\/definitions\/OutputType"},"___prefix":{"type":"string"},"___args":{"description":"arguments passed on the command line","type":"string"},"___includeOnly":{"description":"a regular expression for modules to cruise; anything outside it will be skipped","type":"string"},"___outputTo":{"description":"File the output was written to ('-' for stdout)","type":"string"},"___maxDepth":{"maximum":99,"description":"The maximum cruise depth specified. 0 means no maximum specified","type":"number","minimum":0},"___moduleSystems":{"$ref":"#\/definitions\/ModuleSystemsType"},"___rulesFile":{"description":"The rules file used to validate the dependencies (if any)","type":"string"},"___exclude":{"$ref":"#\/definitions\/CompoundExcludeType"},"___combinedDependencies":{"description":"if true combines the package.jsons found from the module up to the base folder the cruise is initiated from. Useful for how (some) mono-repos manage dependencies & dependency definitions. Defaults to `false`.","type":"boolean"},"___externalModuleResolutionStrategy":{"description":"What external module resolution strategy to use. Defaults to 'node_modules'","type":"string","enum":["node_modules","yarn-pnp"]},"___tsPreCompilationDeps":{"oneOf":[{"type":"boolean"},{"type":"string","enum":["specify"]}],"description":"if true detect dependencies that only exist before typescript-to-javascript compilation."},"___preserveSymlinks":{"description":"if true leave symlinks untouched, otherwise use the realpath. Defaults to `false` (which is also nodejs's default behavior since version 6)","type":"boolean"},"___webpackConfig":{"description":"Webpack configuration to use to get resolve options from","additionalProperties":false,"type":"object","properties":{"___fileName":{"description":"The webpack conf file to use (typically something like 'webpack.conf.js'). The fileName is relative to dependency-cruiser's current working directory. When not provided defaults to '.\/webpack.conf.js'.","type":"string"},"___env":{"oneOf":[{"type":"object"},{"type":"string"}],"description":"Environment to pass if your config file returns a function"},"___arguments":{"description":"Arguments to pass if your config file returns a function. E.g. {mode: 'production'} if you want to use webpack 4's 'mode' feature","type":"object"}}},"___exoticRequireStrings":{"description":"List of strings you have in use in addition to cjs\/ es6 requires & imports to declare module dependencies. Use this e.g. if you've redeclared require (`const want = require`), use a require-wrapper (like semver-try-require) or use window.require as a hack to workaround something","type":"array","items":{"type":"string"}},"___tsConfig":{"description":"Typescript project file ('tsconfig.json') to use for (1) compilation and (2) resolution (e.g. with the paths property)","additionalProperties":false,"type":"object","properties":{"___fileName":{"description":"The typescript project file to use. The fileName is relative to dependency-cruiser's current working directory. When not provided defaults to '.\/tsconfig.json'.","type":"string"}}},"___reporterOptions":{"$ref":"#\/definitions\/ReporterOptionsType"}}}},"___info":{"description":"the number of informational level notices in the dependencies","type":"number"},"___ruleSetUsed":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___forbidden":{"description":"A list of rules that describe dependencies that are not allowed. dependency-cruiser will emit a separate error (warning\/ informational) messages for each violated rule.","type":"array","items":{"$ref":"#\/definitions\/ForbiddenRuleType"}},"___allowed":{"description":"A list of rules that describe dependencies that are allowed. dependency-cruiser will emit the warning message 'not-in-allowed' for each dependency that does not at least meet one of them.","type":"array","items":{"$ref":"#\/definitions\/AllowedRuleType"}},"___allowedSeverity":{"description":"Severity to use when a dependency is not in the 'allowed' set of rules. Defaults to 'warn'","$ref":"#\/definitions\/SeverityType"}}}},"___totalDependenciesCruised":{"description":"the number of dependencies cruised","type":"number"},"___totalCruised":{"description":"the number of modules cruised","type":"number"},"___error":{"description":"the number of errors in the dependencies","type":"number"},"___warn":{"description":"the number of warnings in the dependencies","type":"number"},"___violations":{"$eref":{"description":"A list of violations found in the dependencies. The dependencies themselves also contain this information, this summary is here for convenience.","type":"array","items":{"$ref":"#\/definitions\/ViolationType"}}}},"required":["violations","error","warn","info","totalCruised","optionsUsed"]},"_88RuleSummaryType":{"description":"If there was a rule violation (valid === false), this object contains the name of the rule and severity of violating it.","additionalProperties":false,"type":"object","properties":{"___name":{"description":"The (short, eslint style) name of the violated rule. Typically something like 'no-core-punycode' or 'no-outside-deps'.","type":"string"},"___severity":{"$eref":{"description":"How severe a violation of a rule is. The 'error' severity will make some reporters return a non-zero exit code, so if you want e.g. a build to stop when there's a rule violated: use that.","type":"string","enum":["error","warn","info","ignore"]}}},"required":["name","severity"]},"_88DotThemeArrayType":{"type":"array","items":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___criteria":{"type":"object"},"___attributes":{"type":"object"}}}}},"_88FromRestrictionType":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___orphan":{"description":"Whether or not to match when the module is an orphan (= has no incoming or outgoing dependencies). When this property it is part of a rule, dependency-cruiser will ignore the 'to' part.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}},"_88DependencyTypeType":{"type":"string","enum":["aliased","core","deprecated","local","localmodule","npm","npm-bundled","npm-dev","npm-no-pkg","npm-optional","npm-peer","npm-unknown","undetermined","unknown"]},"_88AnonReporterOptionsType":{"description":"Options to tweak the output of the anonymous reporter","additionalProperties":false,"type":"object","properties":{"___wordlist":{"description":"List of words to use to replace path elements of file names in the output with so the output isn't directly traceable to its intended purpose.When the list is exhausted, the anon reporter will use random strings patterned after the original file name in stead. The list is empty by default. Read more in https:\/\/github.com\/sverweij\/dependency-cruiser\/blob\/develop\/doc\/cli.md#anon---obfuscated-json","type":"array","items":{"type":"string"}}}},"_88ReachableType":{"additionalProperties":false,"type":"object","properties":{"___asDefinedInRule":{"description":"The name of the rule where the reachability was defined","type":"string"},"___value":{"description":"'true' if this module is reachable from any of the modules matched by the from part of a reachability-rule in 'asDefinedInRule', 'false' if not.","type":"boolean"}},"required":["value","asDefinedInRule"]},"_88ViolationType":{"additionalProperties":false,"type":"object","properties":{"___cycle":{"description":"The circular path if the violation was about circularity","type":"array","items":{"type":"string"}},"___rule":{"$eref":{"description":"If there was a rule violation (valid === false), this object contains the name of the rule and severity of violating it.","additionalProperties":false,"type":"object","properties":{"___name":{"description":"The (short, eslint style) name of the violated rule. Typically something like 'no-core-punycode' or 'no-outside-deps'.","type":"string"},"___severity":{"$ref":"#\/definitions\/SeverityType"}},"required":["name","severity"]}},"___to":{"type":"string"},"___from":{"type":"string"}},"required":["from","to","rule"]},"_88ForbiddenRuleType":{"oneOf":[{"$eref":{"additionalProperties":false,"type":"object","properties":{"___name":{"description":"A short name for the rule - will appear in reporters to enable customers to quickly identify a violated rule. Try to keep them short, eslint style. E.g. 'not-to-core' for a rule forbidding dependencies on core modules, or 'not-to-unresolvable' for one that prevents dependencies on modules that probably don't exist.","type":"string"},"___comment":{"description":"You can use this field to document why the rule is there.","type":"string"},"___severity":{"$ref":"#\/definitions\/SeverityType"},"___to":{"$ref":"#\/definitions\/ToRestrictionType"},"___from":{"$ref":"#\/definitions\/FromRestrictionType"}},"required":["from","to"]}},{"$eref":{"additionalProperties":false,"type":"object","properties":{"___name":{"type":"string"},"___comment":{"type":"string"},"___severity":{"$ref":"#\/definitions\/SeverityType"},"___to":{"$ref":"#\/definitions\/ReachabilityToRestrictionType"},"___from":{"$ref":"#\/definitions\/ReachabilityFromRestrictionType"}},"required":["from","to"]}}]},"_88ReachabilityAllowedRuleType":{"additionalProperties":false,"type":"object","properties":{"___comment":{"type":"string"},"___to":{"$eref":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"properties":{"___reachable":{"description":"Whether or not to match modules that aren't reachable from the from part of the rule.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}},"required":["reachable"]}},"___from":{"$eref":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}}}},"required":["from","to"]},"_88ModulesType":{"description":"A list of modules, with for each module the modules it depends upon","type":"array","items":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___rules":{"description":"an array of rules violated by this module - left out if the module is valid","type":"array","items":{"$ref":"#\/definitions\/RuleSummaryType"}},"___reachable":{"description":"An array of objects that tell whether this module is 'reachable', and according to rule in which this reachability was defined","type":"array","items":{"$ref":"#\/definitions\/ReachableType"}},"___coreModule":{"description":"Whether or not this is a node.js core module","type":"boolean"},"___license":{"description":"the license, if known (usually known for modules pulled from npm, not for local ones)","type":"string"},"___dependencies":{"$ref":"#\/definitions\/DependenciesType"},"___couldNotResolve":{"description":"'true' if dependency-cruiser could not resolve the module name in the source code to a file name or core module. 'false' in all other cases.","type":"boolean"},"___orphan":{"description":"'true' if this module does not have dependencies, and no module has it as a dependency","type":"boolean"},"___source":{"description":"The (resolved) file name of the module, e.g. 'src\/main\/index.js'","type":"string"},"___dependencyTypes":{"description":"the type of inclusion - local, core, unknown (= we honestly don't know), undetermined (= we didn't bother determining it) or one of the npm dependencies defined in a package.jsom ('npm' for 'depenencies', 'npm-dev', 'npm-optional', 'npm-peer', 'npm-no-pkg' for development, optional, peer dependencies and dependencies in node_modules but not in package.json respectively)","type":"array","items":{"$ref":"#\/definitions\/DependencyTypeType"}},"___valid":{"description":"'true' if this module violated a rule; 'false' in all other cases. The violated rule will be in the 'rule' object at the same level.","type":"boolean"},"___followable":{"description":"Whether or not this is a dependency that can be followed any further. This will be 'false' for for core modules, json, modules that could not be resolved to a file and modules that weren't followed because it matches the doNotFollow expression.","type":"boolean"},"___consolidated":{"description":"true if the module was 'consolidated'. Consolidating implies the entity a Module represents might be several modules at the same time. This attribute is set by tools that consolidate modules for reporting purposes - it will not be present after a regular cruise.","type":"boolean"},"___matchesDoNotFollow":{"description":"'true' if the file name of this module matches the doNotFollow regular expression","type":"boolean"}},"required":["source","dependencies","valid"]}}},"_88DotThemeEntryType":{"additionalProperties":false,"type":"object","properties":{"___criteria":{"type":"object"},"___attributes":{"type":"object"}}},"_88CompoundDoNotFollowType":{"description":"Criteria for modules to include, but not to follow further","additionalProperties":false,"type":"object","properties":{"___dependencyTypes":{"description":"an array of dependency types to include, but not follow further","type":"array","items":{"$eref":{"type":"string","enum":["aliased","core","deprecated","local","localmodule","npm","npm-bundled","npm-dev","npm-no-pkg","npm-optional","npm-peer","npm-unknown","undetermined","unknown"]}}},"___path":{"description":"a regular expression for modules to include, but not follow further","type":"string"}}},"_88AllowedRuleType":{"oneOf":[{"$eref":{"additionalProperties":false,"type":"object","properties":{"___comment":{"type":"string"},"___to":{"$ref":"#\/definitions\/ToRestrictionType"},"___from":{"$ref":"#\/definitions\/FromRestrictionType"}},"required":["from","to"]}},{"$eref":{"additionalProperties":false,"type":"object","properties":{"___comment":{"type":"string"},"___to":{"$ref":"#\/definitions\/ReachabilityToRestrictionType"},"___from":{"$ref":"#\/definitions\/ReachabilityFromRestrictionType"}},"required":["from","to"]}}]},"_88DotReporterOptionsType":{"description":"Options to tweak the output of the anonymous reporter","additionalProperties":false,"type":"object","properties":{"___theme":{"$eref":{"description":"A bunch of criteria to conditionally theme the dot output","additionalProperties":false,"type":"object","properties":{"___graph":{"description":"Name- value pairs of GraphViz dot (global) attributes.","type":"object"},"___modules":{"description":"List of criteria and attributes to apply for modules when the criteria are met. Conditions can use any module attribute. Attributes can be any that are valid in GraphViz dot nodes.","$ref":"#\/definitions\/DotThemeArrayType"},"___replace":{"description":"If passed with the value 'true', the passed theme replaces the default one. In all other cases it extends the default theme.","type":"boolean"},"___dependencies":{"description":"List of criteria and attributes to apply for dependencies when the criteria are met. Conditions can use any dependency attribute. Attributes can be any that are valid in GraphViz dot edges.","$ref":"#\/definitions\/DotThemeArrayType"},"___edge":{"description":"Name- value pairs of GraphViz dot edge attributes.","type":"object"},"___node":{"description":"Name- value pairs of GraphViz dot node attributes.","type":"object"}}}},"___collapsePattern":{"description":"Regular expressions to collapse to. For the \"dot\" reporter defaults to null, but \"node_modules\/[^\/]+\" is recommended for most use cases.","type":"string"}}},"_88ReachabilityToRestrictionType":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"properties":{"___reachable":{"description":"Whether or not to match modules that aren't reachable from the from part of the rule.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}},"required":["reachable"]},"_88OptionsUsedType":{"description":"the (command line) options used to generate the dependency-tree","additionalProperties":false,"type":"object","properties":{"___doNotFollow":{"$eref":{"description":"Criteria for modules to include, but not to follow further","additionalProperties":false,"type":"object","properties":{"___dependencyTypes":{"description":"an array of dependency types to include, but not follow further","type":"array","items":{"$ref":"#\/definitions\/DependencyTypeType"}},"___path":{"description":"a regular expression for modules to include, but not follow further","type":"string"}}}},"___outputType":{"$eref":{"type":"string","enum":["json","html","dot","ddot","cdot","archi","csv","err","err-long","err-html","teamcity","anon"]}},"___prefix":{"type":"string"},"___args":{"description":"arguments passed on the command line","type":"string"},"___includeOnly":{"description":"a regular expression for modules to cruise; anything outside it will be skipped","type":"string"},"___outputTo":{"description":"File the output was written to ('-' for stdout)","type":"string"},"___maxDepth":{"maximum":99,"description":"The maximum cruise depth specified. 0 means no maximum specified","type":"number","minimum":0},"___moduleSystems":{"$eref":{"description":"List of module systems to cruise. Defaults to [amd, cjs, es6]","type":"array","items":{"$ref":"#\/definitions\/ModuleSystemType"}}},"___rulesFile":{"description":"The rules file used to validate the dependencies (if any)","type":"string"},"___exclude":{"$eref":{"description":"Criteria for dependencies to exclude","additionalProperties":false,"type":"object","properties":{"___dynamic":{"description":"a boolean indicating whether or not to exclude dynamic dependencies","type":"boolean"},"___path":{"description":"a regular expression for modules to exclude from being cruised","type":"string"}}}},"___combinedDependencies":{"description":"if true combines the package.jsons found from the module up to the base folder the cruise is initiated from. Useful for how (some) mono-repos manage dependencies & dependency definitions. Defaults to `false`.","type":"boolean"},"___externalModuleResolutionStrategy":{"description":"What external module resolution strategy to use. Defaults to 'node_modules'","type":"string","enum":["node_modules","yarn-pnp"]},"___tsPreCompilationDeps":{"oneOf":[{"type":"boolean"},{"type":"string","enum":["specify"]}],"description":"if true detect dependencies that only exist before typescript-to-javascript compilation."},"___preserveSymlinks":{"description":"if true leave symlinks untouched, otherwise use the realpath. Defaults to `false` (which is also nodejs's default behavior since version 6)","type":"boolean"},"___webpackConfig":{"description":"Webpack configuration to use to get resolve options from","additionalProperties":false,"type":"object","properties":{"___fileName":{"description":"The webpack conf file to use (typically something like 'webpack.conf.js'). The fileName is relative to dependency-cruiser's current working directory. When not provided defaults to '.\/webpack.conf.js'.","type":"string"},"___env":{"oneOf":[{"type":"object"},{"type":"string"}],"description":"Environment to pass if your config file returns a function"},"___arguments":{"description":"Arguments to pass if your config file returns a function. E.g. {mode: 'production'} if you want to use webpack 4's 'mode' feature","type":"object"}}},"___exoticRequireStrings":{"description":"List of strings you have in use in addition to cjs\/ es6 requires & imports to declare module dependencies. Use this e.g. if you've redeclared require (`const want = require`), use a require-wrapper (like semver-try-require) or use window.require as a hack to workaround something","type":"array","items":{"type":"string"}},"___tsConfig":{"description":"Typescript project file ('tsconfig.json') to use for (1) compilation and (2) resolution (e.g. with the paths property)","additionalProperties":false,"type":"object","properties":{"___fileName":{"description":"The typescript project file to use. The fileName is relative to dependency-cruiser's current working directory. When not provided defaults to '.\/tsconfig.json'.","type":"string"}}},"___reporterOptions":{"$eref":{"description":"Options to tweak the output of reporters","additionalProperties":false,"type":"object","properties":{"___ddot":{"$ref":"#\/definitions\/DotReporterOptionsType"},"___dot":{"$ref":"#\/definitions\/DotReporterOptionsType"},"___archi":{"$ref":"#\/definitions\/ArchiReporterOptionsType"},"___anon":{"$ref":"#\/definitions\/AnonReporterOptionsType"}}}}}},"_88RuleSetType":{"additionalProperties":false,"type":"object","properties":{"___forbidden":{"description":"A list of rules that describe dependencies that are not allowed. dependency-cruiser will emit a separate error (warning\/ informational) messages for each violated rule.","type":"array","items":{"$eref":{"oneOf":[{"$ref":"#\/definitions\/RegularForbiddenRuleType"},{"$ref":"#\/definitions\/ReachabilityForbiddenRuleType"}]}}},"___allowed":{"description":"A list of rules that describe dependencies that are allowed. dependency-cruiser will emit the warning message 'not-in-allowed' for each dependency that does not at least meet one of them.","type":"array","items":{"$eref":{"oneOf":[{"$ref":"#\/definitions\/RegularAllowedRuleType"},{"$ref":"#\/definitions\/ReachabilityAllowedRuleType"}]}}},"___allowedSeverity":{"$eref":{"description":"How severe a violation of a rule is. The 'error' severity will make some reporters return a non-zero exit code, so if you want e.g. a build to stop when there's a rule violated: use that.","type":"string","enum":["error","warn","info","ignore"]},"description":"Severity to use when a dependency is not in the 'allowed' set of rules. Defaults to 'warn'"}}},"_88SeverityType":{"description":"How severe a violation of a rule is. The 'error' severity will make some reporters return a non-zero exit code, so if you want e.g. a build to stop when there's a rule violated: use that.","type":"string","enum":["error","warn","info","ignore"]},"_88DependencyType":{"additionalProperties":false,"type":"object","properties":{"___cycle":{"description":"If following this dependency will ultimately return to the source (circular === true), this attribute will contain an (ordered) array of module names that shows (one of the) circular path(s)","type":"array","items":{"type":"string"}},"___rules":{"description":"an array of rules violated by this dependency - left out if the dependency is valid","type":"array","items":{"$eref":{"description":"If there was a rule violation (valid === false), this object contains the name of the rule and severity of violating it.","additionalProperties":false,"type":"object","properties":{"___name":{"description":"The (short, eslint style) name of the violated rule. Typically something like 'no-core-punycode' or 'no-outside-deps'.","type":"string"},"___severity":{"$ref":"#\/definitions\/SeverityType"}},"required":["name","severity"]}}},"___coreModule":{"description":"Whether or not this is a node.js core module - deprecated in favor of dependencyType === core","type":"boolean"},"___license":{"description":"the license, if known (usually known for modules pulled from npm, not for local ones)","type":"string"},"___exoticRequire":{"description":"If this dependency was defined by a require not named 'require' (as defined in the exoticRequireStrings option): the string that was used","type":"string"},"___circular":{"description":"'true' if following this dependency will ultimately return to the source, false in all other cases","type":"boolean"},"___moduleSystem":{"$eref":{"type":"string","enum":["cjs","es6","amd","tsd"]}},"___couldNotResolve":{"description":"'true' if dependency-cruiser could not resulve the module name in the source code to a file name or core module. 'false' in all other cases.","type":"boolean"},"___dependencyTypes":{"description":"the type of inclusion - local, core, unknown (= we honestly don't know), undetermined (= we didn't bother determining it) or one of the npm dependencies defined in a package.jsom ('npm' for 'depenencies', 'npm-dev', 'npm-optional', 'npm-peer', 'npm-no-pkg' for development, optional, peer dependencies and dependencies in node_modules but not in package.json respectively)","type":"array","items":{"$eref":{"type":"string","enum":["aliased","core","deprecated","local","localmodule","npm","npm-bundled","npm-dev","npm-no-pkg","npm-optional","npm-peer","npm-unknown","undetermined","unknown"]}}},"___valid":{"description":"'true' if this dependency violated a rule; 'false' in all other cases. The violated rule will be in the 'rule' object at the same level.","type":"boolean"},"___followable":{"description":"Whether or not this is a dependency that can be followed any further. This will be 'false' for for core modules, json, modules that could not be resolved to a file and modules that weren't followed because it matches the doNotFollow expression.","type":"boolean"},"___resolved":{"description":"The (resolved) file name of the module, e.g. 'src\/main\/\/index.js'","type":"string"},"___exoticallyRequired":{"description":"true if the dependency was defined by a require function not named'require' - false in all other cases","type":"boolean"},"___dynamic":{"description":"true if this dependency is dynamic, false in all other cases","type":"boolean"},"___module":{"description":"The name of the module as it appeared in the source code, e.g. '.\/main'","type":"string"},"___matchesDoNotFollow":{"description":"'true' if the file name of this module matches the doNotFollow regular expression","type":"boolean"}},"required":["module","resolved","coreModule","dependencyTypes","followable","couldNotResolve","moduleSystem","valid","dynamic"]},"_88ModuleSystemsType":{"description":"List of module systems to cruise. Defaults to [amd, cjs, es6]","type":"array","items":{"$eref":{"type":"string","enum":["cjs","es6","amd","tsd"]}}},"_88CompoundExcludeType":{"description":"Criteria for dependencies to exclude","additionalProperties":false,"type":"object","properties":{"___dynamic":{"description":"a boolean indicating whether or not to exclude dynamic dependencies","type":"boolean"},"___path":{"description":"a regular expression for modules to exclude from being cruised","type":"string"}}},"_88ToRestrictionType":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___license":{"description":"Whether or not to match modules that were released under one of the mentioned licenses. E.g. to flag GPL-1.0, GPL-2.0 licensed modules (e.g. because your app is not compatible with the GPL) use \"GPL\"","type":"string"},"___exoticRequire":{"description":"A regular expression to match against any 'exotic' require strings","type":"string"},"___circular":{"description":"Whether or not to match when following to the to will ultimately end up in the from.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___licenseNot":{"description":"Whether or not to match modules that were NOT released under one of the mentioned licenses. E.g. to flag everyting non MIT use \"MIT\" here","type":"string"},"___couldNotResolve":{"description":"Whether or not to match modules dependency-cruiser could not resolve (and probably aren't on disk). For this one too: leave out if you don't care either way.","type":"boolean"},"___moreThanOneDependencyType":{"description":"If true matches dependencies with more than one dependency type (e.g. defined in _both_ npm and npm-dev)","type":"boolean"},"___dependencyTypes":{"description":"Whether or not to match modules of any of these types (leaving out matches any of them)","type":"array","items":{"$eref":{"type":"string","enum":["aliased","core","deprecated","local","localmodule","npm","npm-bundled","npm-dev","npm-no-pkg","npm-optional","npm-peer","npm-unknown","undetermined","unknown"]}}},"___exoticRequireNot":{"description":"A regular expression to match against any 'exotic' require strings - when it should NOT be caught by the rule","type":"string"},"___exoticallyRequired":{"description":"Whether or not to match when the dependency is exotically required.","type":"boolean"},"___dynamic":{"description":"Whether or not to match when the dependency is a dynamic one.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"},"___preCompilationOnly":{"description":"true if this dependency only exists before compilation (like type only imports), false in all other cases. Only returned when the tsPreCompilationDeps is set to 'specify'.","type":"boolean"}}},"_88ViolationsType":{"description":"A list of violations found in the dependencies. The dependencies themselves also contain this information, this summary is here for convenience.","type":"array","items":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___cycle":{"description":"The circular path if the violation was about circularity","type":"array","items":{"type":"string"}},"___rule":{"$ref":"#\/definitions\/RuleSummaryType"},"___to":{"type":"string"},"___from":{"type":"string"}},"required":["from","to","rule"]}}},"_88ReachabilityFromRestrictionType":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}},"_88DotThemeType":{"description":"A bunch of criteria to conditionally theme the dot output","additionalProperties":false,"type":"object","properties":{"___graph":{"description":"Name- value pairs of GraphViz dot (global) attributes.","type":"object"},"___modules":{"$eref":{"type":"array","items":{"$ref":"#\/definitions\/DotThemeEntryType"}},"description":"List of criteria and attributes to apply for modules when the criteria are met. Conditions can use any module attribute. Attributes can be any that are valid in GraphViz dot nodes."},"___replace":{"description":"If passed with the value 'true', the passed theme replaces the default one. In all other cases it extends the default theme.","type":"boolean"},"___dependencies":{"$eref":{"type":"array","items":{"$ref":"#\/definitions\/DotThemeEntryType"}},"description":"List of criteria and attributes to apply for dependencies when the criteria are met. Conditions can use any dependency attribute. Attributes can be any that are valid in GraphViz dot edges."},"___edge":{"description":"Name- value pairs of GraphViz dot edge attributes.","type":"object"},"___node":{"description":"Name- value pairs of GraphViz dot node attributes.","type":"object"}}},"_88ArchiReporterOptionsType":{"description":"Options to tweak the output of customized dot\/ architecture reporter","additionalProperties":false,"type":"object","properties":{"___theme":{"$eref":{"description":"A bunch of criteria to conditionally theme the dot output","additionalProperties":false,"type":"object","properties":{"___graph":{"description":"Name- value pairs of GraphViz dot (global) attributes.","type":"object"},"___modules":{"description":"List of criteria and attributes to apply for modules when the criteria are met. Conditions can use any module attribute. Attributes can be any that are valid in GraphViz dot nodes.","$ref":"#\/definitions\/DotThemeArrayType"},"___replace":{"description":"If passed with the value 'true', the passed theme replaces the default one. In all other cases it extends the default theme.","type":"boolean"},"___dependencies":{"description":"List of criteria and attributes to apply for dependencies when the criteria are met. Conditions can use any dependency attribute. Attributes can be any that are valid in GraphViz dot edges.","$ref":"#\/definitions\/DotThemeArrayType"},"___edge":{"description":"Name- value pairs of GraphViz dot edge attributes.","type":"object"},"___node":{"description":"Name- value pairs of GraphViz dot node attributes.","type":"object"}}}},"___collapsePattern":{"description":"Regular expressions to collapse to (e.g. \"^node_modules\/[^\/]+|^src\/[^\/]+\")","type":"string"}}},"_88ReporterOptionsType":{"description":"Options to tweak the output of reporters","additionalProperties":false,"type":"object","properties":{"___ddot":{"$eref":{"description":"Options to tweak the output of the anonymous reporter","additionalProperties":false,"type":"object","properties":{"___theme":{"$ref":"#\/definitions\/DotThemeType"},"___collapsePattern":{"description":"Regular expressions to collapse to. For the \"dot\" reporter defaults to null, but \"node_modules\/[^\/]+\" is recommended for most use cases.","type":"string"}}}},"___dot":{"$eref":{"description":"Options to tweak the output of the anonymous reporter","additionalProperties":false,"type":"object","properties":{"___theme":{"$ref":"#\/definitions\/DotThemeType"},"___collapsePattern":{"description":"Regular expressions to collapse to. For the \"dot\" reporter defaults to null, but \"node_modules\/[^\/]+\" is recommended for most use cases.","type":"string"}}}},"___archi":{"$eref":{"description":"Options to tweak the output of customized dot\/ architecture reporter","additionalProperties":false,"type":"object","properties":{"___theme":{"$ref":"#\/definitions\/DotThemeType"},"___collapsePattern":{"description":"Regular expressions to collapse to (e.g. \"^node_modules\/[^\/]+|^src\/[^\/]+\")","type":"string"}}}},"___anon":{"$eref":{"description":"Options to tweak the output of the anonymous reporter","additionalProperties":false,"type":"object","properties":{"___wordlist":{"description":"List of words to use to replace path elements of file names in the output with so the output isn't directly traceable to its intended purpose.When the list is exhausted, the anon reporter will use random strings patterned after the original file name in stead. The list is empty by default. Read more in https:\/\/github.com\/sverweij\/dependency-cruiser\/blob\/develop\/doc\/cli.md#anon---obfuscated-json","type":"array","items":{"type":"string"}}}}}}},"_88ModuleType":{"additionalProperties":false,"type":"object","properties":{"___rules":{"description":"an array of rules violated by this module - left out if the module is valid","type":"array","items":{"$eref":{"description":"If there was a rule violation (valid === false), this object contains the name of the rule and severity of violating it.","additionalProperties":false,"type":"object","properties":{"___name":{"description":"The (short, eslint style) name of the violated rule. Typically something like 'no-core-punycode' or 'no-outside-deps'.","type":"string"},"___severity":{"$ref":"#\/definitions\/SeverityType"}},"required":["name","severity"]}}},"___reachable":{"description":"An array of objects that tell whether this module is 'reachable', and according to rule in which this reachability was defined","type":"array","items":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___asDefinedInRule":{"description":"The name of the rule where the reachability was defined","type":"string"},"___value":{"description":"'true' if this module is reachable from any of the modules matched by the from part of a reachability-rule in 'asDefinedInRule', 'false' if not.","type":"boolean"}},"required":["value","asDefinedInRule"]}}},"___coreModule":{"description":"Whether or not this is a node.js core module","type":"boolean"},"___license":{"description":"the license, if known (usually known for modules pulled from npm, not for local ones)","type":"string"},"___dependencies":{"$eref":{"type":"array","items":{"$ref":"#\/definitions\/DependencyType"}}},"___couldNotResolve":{"description":"'true' if dependency-cruiser could not resolve the module name in the source code to a file name or core module. 'false' in all other cases.","type":"boolean"},"___orphan":{"description":"'true' if this module does not have dependencies, and no module has it as a dependency","type":"boolean"},"___source":{"description":"The (resolved) file name of the module, e.g. 'src\/main\/index.js'","type":"string"},"___dependencyTypes":{"description":"the type of inclusion - local, core, unknown (= we honestly don't know), undetermined (= we didn't bother determining it) or one of the npm dependencies defined in a package.jsom ('npm' for 'depenencies', 'npm-dev', 'npm-optional', 'npm-peer', 'npm-no-pkg' for development, optional, peer dependencies and dependencies in node_modules but not in package.json respectively)","type":"array","items":{"$eref":{"type":"string","enum":["aliased","core","deprecated","local","localmodule","npm","npm-bundled","npm-dev","npm-no-pkg","npm-optional","npm-peer","npm-unknown","undetermined","unknown"]}}},"___valid":{"description":"'true' if this module violated a rule; 'false' in all other cases. The violated rule will be in the 'rule' object at the same level.","type":"boolean"},"___followable":{"description":"Whether or not this is a dependency that can be followed any further. This will be 'false' for for core modules, json, modules that could not be resolved to a file and modules that weren't followed because it matches the doNotFollow expression.","type":"boolean"},"___consolidated":{"description":"true if the module was 'consolidated'. Consolidating implies the entity a Module represents might be several modules at the same time. This attribute is set by tools that consolidate modules for reporting purposes - it will not be present after a regular cruise.","type":"boolean"},"___matchesDoNotFollow":{"description":"'true' if the file name of this module matches the doNotFollow regular expression","type":"boolean"}},"required":["source","dependencies","valid"]},"_88ReachabilityForbiddenRuleType":{"additionalProperties":false,"type":"object","properties":{"___name":{"type":"string"},"___comment":{"type":"string"},"___severity":{"$eref":{"description":"How severe a violation of a rule is. The 'error' severity will make some reporters return a non-zero exit code, so if you want e.g. a build to stop when there's a rule violated: use that.","type":"string","enum":["error","warn","info","ignore"]}},"___to":{"$eref":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"properties":{"___reachable":{"description":"Whether or not to match modules that aren't reachable from the from part of the rule.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}},"required":["reachable"]}},"___from":{"$eref":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}}}},"required":["from","to"]},"_88RegularForbiddenRuleType":{"additionalProperties":false,"type":"object","properties":{"___name":{"description":"A short name for the rule - will appear in reporters to enable customers to quickly identify a violated rule. Try to keep them short, eslint style. E.g. 'not-to-core' for a rule forbidding dependencies on core modules, or 'not-to-unresolvable' for one that prevents dependencies on modules that probably don't exist.","type":"string"},"___comment":{"description":"You can use this field to document why the rule is there.","type":"string"},"___severity":{"$eref":{"description":"How severe a violation of a rule is. The 'error' severity will make some reporters return a non-zero exit code, so if you want e.g. a build to stop when there's a rule violated: use that.","type":"string","enum":["error","warn","info","ignore"]}},"___to":{"$eref":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___license":{"description":"Whether or not to match modules that were released under one of the mentioned licenses. E.g. to flag GPL-1.0, GPL-2.0 licensed modules (e.g. because your app is not compatible with the GPL) use \"GPL\"","type":"string"},"___exoticRequire":{"description":"A regular expression to match against any 'exotic' require strings","type":"string"},"___circular":{"description":"Whether or not to match when following to the to will ultimately end up in the from.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___licenseNot":{"description":"Whether or not to match modules that were NOT released under one of the mentioned licenses. E.g. to flag everyting non MIT use \"MIT\" here","type":"string"},"___couldNotResolve":{"description":"Whether or not to match modules dependency-cruiser could not resolve (and probably aren't on disk). For this one too: leave out if you don't care either way.","type":"boolean"},"___moreThanOneDependencyType":{"description":"If true matches dependencies with more than one dependency type (e.g. defined in _both_ npm and npm-dev)","type":"boolean"},"___dependencyTypes":{"description":"Whether or not to match modules of any of these types (leaving out matches any of them)","type":"array","items":{"$ref":"#\/definitions\/DependencyTypeType"}},"___exoticRequireNot":{"description":"A regular expression to match against any 'exotic' require strings - when it should NOT be caught by the rule","type":"string"},"___exoticallyRequired":{"description":"Whether or not to match when the dependency is exotically required.","type":"boolean"},"___dynamic":{"description":"Whether or not to match when the dependency is a dynamic one.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"},"___preCompilationOnly":{"description":"true if this dependency only exists before compilation (like type only imports), false in all other cases. Only returned when the tsPreCompilationDeps is set to 'specify'.","type":"boolean"}}}},"___from":{"$eref":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___orphan":{"description":"Whether or not to match when the module is an orphan (= has no incoming or outgoing dependencies). When this property it is part of a rule, dependency-cruiser will ignore the 'to' part.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}}}},"required":["from","to"]},"_88ModuleSystemType":{"type":"string","enum":["cjs","es6","amd","tsd"]},"_88DependenciesType":{"type":"array","items":{"$eref":{"additionalProperties":false,"type":"object","properties":{"___cycle":{"description":"If following this dependency will ultimately return to the source (circular === true), this attribute will contain an (ordered) array of module names that shows (one of the) circular path(s)","type":"array","items":{"type":"string"}},"___rules":{"description":"an array of rules violated by this dependency - left out if the dependency is valid","type":"array","items":{"$ref":"#\/definitions\/RuleSummaryType"}},"___coreModule":{"description":"Whether or not this is a node.js core module - deprecated in favor of dependencyType === core","type":"boolean"},"___license":{"description":"the license, if known (usually known for modules pulled from npm, not for local ones)","type":"string"},"___exoticRequire":{"description":"If this dependency was defined by a require not named 'require' (as defined in the exoticRequireStrings option): the string that was used","type":"string"},"___circular":{"description":"'true' if following this dependency will ultimately return to the source, false in all other cases","type":"boolean"},"___moduleSystem":{"$ref":"#\/definitions\/ModuleSystemType"},"___couldNotResolve":{"description":"'true' if dependency-cruiser could not resulve the module name in the source code to a file name or core module. 'false' in all other cases.","type":"boolean"},"___dependencyTypes":{"description":"the type of inclusion - local, core, unknown (= we honestly don't know), undetermined (= we didn't bother determining it) or one of the npm dependencies defined in a package.jsom ('npm' for 'depenencies', 'npm-dev', 'npm-optional', 'npm-peer', 'npm-no-pkg' for development, optional, peer dependencies and dependencies in node_modules but not in package.json respectively)","type":"array","items":{"$ref":"#\/definitions\/DependencyTypeType"}},"___valid":{"description":"'true' if this dependency violated a rule; 'false' in all other cases. The violated rule will be in the 'rule' object at the same level.","type":"boolean"},"___followable":{"description":"Whether or not this is a dependency that can be followed any further. This will be 'false' for for core modules, json, modules that could not be resolved to a file and modules that weren't followed because it matches the doNotFollow expression.","type":"boolean"},"___resolved":{"description":"The (resolved) file name of the module, e.g. 'src\/main\/\/index.js'","type":"string"},"___exoticallyRequired":{"description":"true if the dependency was defined by a require function not named'require' - false in all other cases","type":"boolean"},"___dynamic":{"description":"true if this dependency is dynamic, false in all other cases","type":"boolean"},"___module":{"description":"The name of the module as it appeared in the source code, e.g. '.\/main'","type":"string"},"___matchesDoNotFollow":{"description":"'true' if the file name of this module matches the doNotFollow regular expression","type":"boolean"}},"required":["module","resolved","coreModule","dependencyTypes","followable","couldNotResolve","moduleSystem","valid","dynamic"]}}},"_88RegularAllowedRuleType":{"additionalProperties":false,"type":"object","properties":{"___comment":{"type":"string"},"___to":{"$eref":{"description":"Criteria the 'to' end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___license":{"description":"Whether or not to match modules that were released under one of the mentioned licenses. E.g. to flag GPL-1.0, GPL-2.0 licensed modules (e.g. because your app is not compatible with the GPL) use \"GPL\"","type":"string"},"___exoticRequire":{"description":"A regular expression to match against any 'exotic' require strings","type":"string"},"___circular":{"description":"Whether or not to match when following to the to will ultimately end up in the from.","type":"boolean"},"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___licenseNot":{"description":"Whether or not to match modules that were NOT released under one of the mentioned licenses. E.g. to flag everyting non MIT use \"MIT\" here","type":"string"},"___couldNotResolve":{"description":"Whether or not to match modules dependency-cruiser could not resolve (and probably aren't on disk). For this one too: leave out if you don't care either way.","type":"boolean"},"___moreThanOneDependencyType":{"description":"If true matches dependencies with more than one dependency type (e.g. defined in _both_ npm and npm-dev)","type":"boolean"},"___dependencyTypes":{"description":"Whether or not to match modules of any of these types (leaving out matches any of them)","type":"array","items":{"$ref":"#\/definitions\/DependencyTypeType"}},"___exoticRequireNot":{"description":"A regular expression to match against any 'exotic' require strings - when it should NOT be caught by the rule","type":"string"},"___exoticallyRequired":{"description":"Whether or not to match when the dependency is exotically required.","type":"boolean"},"___dynamic":{"description":"Whether or not to match when the dependency is a dynamic one.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"},"___preCompilationOnly":{"description":"true if this dependency only exists before compilation (like type only imports), false in all other cases. Only returned when the tsPreCompilationDeps is set to 'specify'.","type":"boolean"}}}},"___from":{"$eref":{"description":"Criteria an end of a dependency should match to be caught by this rule. Leave it empty if you want any module to be matched.","additionalProperties":false,"type":"object","properties":{"___pathNot":{"description":"A regular expression an end of a dependency should NOT match to be catched by this rule.","type":"string"},"___orphan":{"description":"Whether or not to match when the module is an orphan (= has no incoming or outgoing dependencies). When this property it is part of a rule, dependency-cruiser will ignore the 'to' part.","type":"boolean"},"___path":{"description":"A regular expression an end of a dependency should match to be catched by this rule.","type":"string"}}}}},"required":["from","to"]},"_88OutputType":{"type":"string","enum":["json","html","dot","ddot","cdot","archi","csv","err","err-long","err-html","teamcity","anon"]}},"properties":{"___modules":{"$eref":{"description":"A list of modules, with for each module the modules it depends upon","type":"array","items":{"$ref":"#\/definitions\/ModuleType"}}},"___summary":{"$eref":{"description":"Data summarizing the found dependencies","additionalProperties":false,"type":"object","properties":{"___optionsUsed":{"$ref":"#\/definitions\/OptionsUsedType"},"___info":{"description":"the number of informational level notices in the dependencies","type":"number"},"___ruleSetUsed":{"$ref":"#\/definitions\/RuleSetType"},"___totalDependenciesCruised":{"description":"the number of dependencies cruised","type":"number"},"___totalCruised":{"description":"the number of modules cruised","type":"number"},"___error":{"description":"the number of errors in the dependencies","type":"number"},"___warn":{"description":"the number of warnings in the dependencies","type":"number"},"___violations":{"$ref":"#\/definitions\/ViolationsType"}},"required":["violations","error","warn","info","totalCruised","optionsUsed"]}}},"required":["summary","modules"],"$id":"https:\/\/dependency-cruiser.js.org\/schema\/cruise-result.schema.json"}