{"$schema":"http:\/\/json-schema.org\/draft-04\/schema#","type":"object","definitions":{"_88meterInvalid":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___protocol":{"type":"string","enum":["invalid"]}}}],"title":"invalid config for a meter. Choose any of the supported ones."},"_88channel":{"type":"object","title":"channel","properties":{"___aggmode":{"default":"none","description":"Mittelwert fuer Leistung, MAX fuer Zaehler, SUM fuer Counter","type":"string","enum":["avg","max","sum","none"]},"___duplicates":{"default":0,"description":"default 0 (send duplicate values), >0 = send duplicate values only each <duplicates> seconds. Activate only for abs. counter values (Zaehlerstaende) and not for impulses!","type":"integer","minimum":0},"___uuid":{"description":"uuid of this channel towards the middleware","type":"string"},"___type":{"default":"device","description":"type of connected meter. Only needed for MySmartGrid api.","type":"string","enum":["device","sensor"]},"___scaler":{"default":1,"description":"scaling factor to use. Only needed for MySmartGrid api.","type":"integer"},"___secretKey":{"description":"secret key to use to talk to MySmartGrid api.","type":"string"},"___middleware":{"default":"http:\/\/localhost\/middleware.php","description":"path\/url to the api\/middleware","type":"string"},"___api":{"default":"volkszaehler","description":"middleware api to be used. Defaults to volkszaehler.org","type":"string","enum":["volkszaehler","mysmartgrid","null"]},"___identifier":{"description":"identifier of this channel from the meter. E.g. 1-0:1.8.0","type":"string"}},"required":["uuid","identifier"]},"_88pushdataentry":{"type":"object","title":"pushdataentry","properties":{"___url":{"description":"full URL of the middleware to push data to e.g. http:\/\/127.0.0.1\/push\/data.json","type":"string"}},"required":["url"]},"_88local":{"type":"object","properties":{"___index":{"description":"should we provide a index listing of available channels if no UUID was requested?","id":"\/local\/index","type":"boolean"},"___timeout":{"id":"\/local\/timeout","type":"integer"},"___enabled":{"description":"should we start the local HTTPd for serving live readings?","id":"\/local\/enabled","type":"boolean"},"___port":{"default":8080,"description":"the TCP port for the local HTTPd","id":"\/local\/port","type":"integer"},"___buffer":{"id":"\/local\/buffer","type":"integer"}},"required":["enabled"]},"_88meterOCRRecognizerNeedle":{"allOf":[{"$eref":{"type":"object","properties":{"___boundingboxes":{"oneOf":[{"$ref":"#\/definitions\/meterOCRBBInvalid"},{"$ref":"#\/definitions\/meterOCRBBCircle"},{"$ref":"#\/definitions\/meterOCRBBBox"}]}}}},{"properties":{"___type":{"type":"string","enum":["needle"]},"___kernelColorString":{"description":"Color conversion 3x3 matrix. Default red channel only (2 -1 -1 0 0 0 0 0 0). First line channel red. Needles are detected for red color after matrix application. See leptonica:pixMultMatrixColor","type":"string"}}}],"title":"needle type recognizer"},"_88meterOCRBB":{"type":"object","properties":{"___digit":{"default":false,"description":"a single digit is expected (thus the recognized value can only be within -9..9)","type":"boolean"},"___scaler":{"default":0,"description":"Scaling factor by 10^<scaler>. E.g. 0 = *1, -1 = *0.1, 2 = *100","type":"integer"},"___identifier":{"description":"id (obis-like) for this reading","type":"string"}}},"_88meterOCRBBCircle":{"allOf":[{"$eref":{"type":"object","properties":{"___digit":{"default":false,"description":"a single digit is expected (thus the recognized value can only be within -9..9)","type":"boolean"},"___scaler":{"default":0,"description":"Scaling factor by 10^<scaler>. E.g. 0 = *1, -1 = *0.1, 2 = *100","type":"integer"},"___identifier":{"description":"id (obis-like) for this reading","type":"string"}}}},{"properties":{"___type":{"type":"string","enum":["circle"]},"___circle":{"type":"object","properties":{"___cy":{"description":"y coordinate of the center of the circle","type":"integer"},"___cx":{"description":"x coordinate of the center of the circle (top-left corner is (0,0))","type":"integer"},"___cr":{"default":10,"description":"radius of the circle. 10 pixel minimum.","type":"integer"},"___offset":{"default":0,"description":"offset of this needle. E.g. if at 5.0 (2nd digit needle at zero) but this needle show ~4.6 enter offset 0.4.","type":"number"}}}}}],"title":"bounding-box with a circle"},"_88meterD0":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___pullseq":{"description":"sequence in hex to send to the meter before each read call. E.g. 2F3F210D0A","type":"string"},"___parity":{"default":"7e1","description":"parity used for serial communication","type":"string","enum":["8n1","7n1","7e1","7o1"]},"___ackseq":{"default":"auto","description":"Reply sequence towards the meter. Should indicate the baud rate wanted. Will be send with initial baudrate. E.g. 063030300d0a for 300 baud. Use 'auto' to let vzlogger determine.","type":"string"},"___baudrate_change_delay":{"default":0,"description":"Delay in ms to apply before changing the baudrate. Defaults to 0 where tcdrain is used instead of a timeout.","type":"integer"},"___protocol":{"type":"string","enum":["d0"]},"___wait_sync":{"default":"off","description":"Wait once for the sync pattern '!'. Intended for meters that start sending data automatically without pullseq.","type":"string","enum":["end","off"]},"___read_timeout":{"default":10,"description":"Read timeout in secs. Data readout is considered finished if no state change after that timeout.","type":"integer"},"___dump_file":{"description":"path\/filename of the file for the serial dump","type":"string"},"___baudrate_read":{"default":300,"description":"Baudrate to be used after initial handshake (pullseq\/answer\/ackseq). Has to fit to ackseq. Will be determined automatically if ackseq 'auto' is used.","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___device":{"description":"device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":300,"description":"Baudrate to be used to for initial communication with the meter.","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___host":{"description":"ip addr of the meter (if not directly connected)","type":"string"}}}],"title":"D0 based meter"},"_88meterW1therm":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___protocol":{"type":"string","enum":["w1therm"]}}}],"title":"w1-therm \/ 1wire temperature sensors"},"_88meterOCRRecognizerInvalid":{"allOf":[{"$eref":{"type":"object","properties":{"___boundingboxes":{"oneOf":[{"$ref":"#\/definitions\/meterOCRBBInvalid"},{"$ref":"#\/definitions\/meterOCRBBCircle"},{"$ref":"#\/definitions\/meterOCRBBBox"}]}}}},{"properties":{"___type":{"type":"string","enum":["invalid"]}}}],"title":"invalid recognizer. Choose any of the supported ones."},"_88meters":{"minItems":1,"type":"array","items":{"oneOf":[{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___protocol":{"type":"string","enum":["invalid"]}}}],"title":"invalid config for a meter. Choose any of the supported ones."}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___resolution":{"default":1000,"description":"number of impulses per kWh","type":"integer"},"___gpio_dir":{"default":-1,"description":"Number of GPIO port to be used as directional pin. If this pin is used and active Impulses_neg instead of Impulses is returned. Keep to -1 if unsure about the purpose.","type":"integer"},"___mmap":{"default":"","description":"For gpio based devices and high frequency signals (>5-10kHz on a rpi2) memory mapped gpio can be used. Currently only supported on Raspberry-Pi 1 or 2. Leads to a constant but high CPU load depending on nonblocking_delay value. MMAPed GPIO pins need to be configured manually as input pins.","type":"string","enum":["","rpi1","rpi2"]},"___configureGPIO":{"default":true,"description":"If true then vzlogger will export, configure,... the GPIO port. Needs proper access rights to \/sys\/class\/gpio\/.","type":"boolean"},"___send_zero":{"default":false,"description":"If active\/true send data once a second even if no impulses have been received. Use aggregation is this case to reduce frequency.","type":"boolean"},"___protocol":{"type":"string","enum":["s0"]},"___debounce_delay":{"default":30,"description":"Delay in ms until the next edge is detected","type":"integer"},"___gpio":{"default":-1,"description":"Number of GPIO port to be used. If this is set >-1 then device is ignored.","type":"integer"},"___device":{"description":"UART device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___nonblocking_delay":{"default":100000,"description":"Delay in ns for polling\/non-blocking interface. On an rpi2 e.g. 5000 can be used to detect up to 30kHz signals with mmap active.","type":"integer"}},"required":["protocol","device"]}],"title":"S0 based meter"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___pullseq":{"description":"sequence in hex to send to the meter before each read call. E.g. 2F3F210D0A","type":"string"},"___parity":{"default":"7e1","description":"parity used for serial communication","type":"string","enum":["8n1","7n1","7e1","7o1"]},"___ackseq":{"default":"auto","description":"Reply sequence towards the meter. Should indicate the baud rate wanted. Will be send with initial baudrate. E.g. 063030300d0a for 300 baud. Use 'auto' to let vzlogger determine.","type":"string"},"___baudrate_change_delay":{"default":0,"description":"Delay in ms to apply before changing the baudrate. Defaults to 0 where tcdrain is used instead of a timeout.","type":"integer"},"___protocol":{"type":"string","enum":["d0"]},"___wait_sync":{"default":"off","description":"Wait once for the sync pattern '!'. Intended for meters that start sending data automatically without pullseq.","type":"string","enum":["end","off"]},"___read_timeout":{"default":10,"description":"Read timeout in secs. Data readout is considered finished if no state change after that timeout.","type":"integer"},"___dump_file":{"description":"path\/filename of the file for the serial dump","type":"string"},"___baudrate_read":{"default":300,"description":"Baudrate to be used after initial handshake (pullseq\/answer\/ackseq). Has to fit to ackseq. Will be determined automatically if ackseq 'auto' is used.","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___device":{"description":"device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":300,"description":"Baudrate to be used to for initial communication with the meter.","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___host":{"description":"ip addr of the meter (if not directly connected)","type":"string"}}}],"title":"D0 based meter"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___pullseq":{"description":"sequence in hex to send to the meter before each read call","type":"string"},"___parity":{"default":"8n1","description":"parity used for serial communication","type":"string","enum":["8n1","7n1","7e1","7o1"]},"___protocol":{"type":"string","enum":["sml"]},"___device":{"description":"device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":9600,"description":"baudrate for serial communication","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___host":{"description":"ip addr of the meter (if not directly connected)","type":"string"}}}],"title":"SML based meter"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___min":{"description":"minimum value (floating point) that will be returned. E.g. 0.0","type":"number"},"___max":{"description":"maximum value (floating point) that will be returned. E.g. 10.0","type":"number"},"___protocol":{"type":"string","enum":["random"]}}}],"title":"example meter returning random values"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___format":{"description":"optional format string. Supports $v for value, $i for identifier and $t for timestamp. E.g. $i:$v. If empty just a value is read from each line of the file.","type":"string"},"___protocol":{"type":"string","enum":["file"]},"___rewind":{"default":false,"description":"rewind the file handle at each read?","type":"boolean"},"___path":{"description":"file incl. path to be used for data extraction","type":"string"}},"required":["path"]}],"title":"meter extracting data from a given file"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___format":{"description":"optional format string. Supports $v for value, $i for identifier and $t for timestamp. E.g. $i:$v. If empty just a value is read from each line of the file.","type":"string"},"___command":{"description":"Command to be executed. Only possible if running as non root. Output will be parsed.","type":"string"},"___protocol":{"type":"string","enum":["exec"]}},"required":["command"]}],"title":"meter extracting data from the output of a shell command\/executable"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___protocol":{"type":"string","enum":["fluksov2"]},"___fifo":{"default":"\/var\/run\/spid\/delta\/out","description":"fifo to be used.","type":"string"}},"required":["fifo"]}],"title":"fluksov2 meter"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___v4l2_dev":{"description":"v4l2 device name (e.g. \/dev\/video0). Keep empty if file based image should be used. Has preference over file.","type":"string"},"___impulses":{"default":0,"description":"0 = report absolute values, >0 = report given impulses per unit","type":"integer"},"___rotate":{"default":0,"description":"angle in degree for rotation of the image. Positive angle turn clockwise.","type":"number"},"___protocol":{"type":"string","enum":["ocr"]},"___recognizer":{"type":"array","items":{"oneOf":[{"$ref":"#\/definitions\/meterOCRRecognizerInvalid"},{"$ref":"#\/definitions\/meterOCRRecognizerNeedle"},{"$ref":"#\/definitions\/meterOCRRecognizerBinary"}]}},"___generate_debug_image":{"default":false,"description":"generate debug images to ease configuration. Will be created in \/run\/vzlogger<nr>_debug.jpg for v4l2 or as <file>_debug.jpg if file based detection is used.","type":"boolean"},"___file":{"default":"\/mnt\/ramdisk\/image.png","description":"filename of the image to be processed (or use v4l2_dev)","type":"string"}}}],"title":"meter extracting data from images (meterOCR)"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___mbus_debug":{"default":false,"description":"provide some more debug output on console by calling some libmbus debug functions","type":"boolean"},"___key":{"description":"AES key for the device in hex. Needs to be exactly 32 characters. E.g. 0102030405060708090a0b0c0d0e0f10","type":"string"},"___protocol":{"type":"string","enum":["oms"]},"___device":{"description":"serial device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":9600,"description":"Baudrate to use. Default to 9600.","type":"number"}},"required":["device","key"]}],"title":"OMS \/ OMS (M-Bus) based devices"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meter"},{"properties":{"___protocol":{"type":"string","enum":["w1therm"]}}}],"title":"w1-therm \/ 1wire temperature sensors"}}]}},"_88meter":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$eref":{"type":"array","items":{"oneOf":[{"$ref":"#\/definitions\/channel"}]}}},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]},"_88channels":{"type":"array","items":{"oneOf":[{"$eref":{"type":"object","title":"channel","properties":{"___aggmode":{"default":"none","description":"Mittelwert fuer Leistung, MAX fuer Zaehler, SUM fuer Counter","type":"string","enum":["avg","max","sum","none"]},"___duplicates":{"default":0,"description":"default 0 (send duplicate values), >0 = send duplicate values only each <duplicates> seconds. Activate only for abs. counter values (Zaehlerstaende) and not for impulses!","type":"integer","minimum":0},"___uuid":{"description":"uuid of this channel towards the middleware","type":"string"},"___type":{"default":"device","description":"type of connected meter. Only needed for MySmartGrid api.","type":"string","enum":["device","sensor"]},"___scaler":{"default":1,"description":"scaling factor to use. Only needed for MySmartGrid api.","type":"integer"},"___secretKey":{"description":"secret key to use to talk to MySmartGrid api.","type":"string"},"___middleware":{"default":"http:\/\/localhost\/middleware.php","description":"path\/url to the api\/middleware","type":"string"},"___api":{"default":"volkszaehler","description":"middleware api to be used. Defaults to volkszaehler.org","type":"string","enum":["volkszaehler","mysmartgrid","null"]},"___identifier":{"description":"identifier of this channel from the meter. E.g. 1-0:1.8.0","type":"string"}},"required":["uuid","identifier"]}}]}},"_88meterOCRRecognizer":{"type":"object","properties":{"___boundingboxes":{"oneOf":[{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRBB"},{"properties":{"___type":{"type":"string","enum":["invalid"]}}}],"title":"invalid bounding-box. Choose any of the supported ones."}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRBB"},{"properties":{"___type":{"type":"string","enum":["circle"]},"___circle":{"type":"object","properties":{"___cy":{"description":"y coordinate of the center of the circle","type":"integer"},"___cx":{"description":"x coordinate of the center of the circle (top-left corner is (0,0))","type":"integer"},"___cr":{"default":10,"description":"radius of the circle. 10 pixel minimum.","type":"integer"},"___offset":{"default":0,"description":"offset of this needle. E.g. if at 5.0 (2nd digit needle at zero) but this needle show ~4.6 enter offset 0.4.","type":"number"}}}}}],"title":"bounding-box with a circle"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRBB"},{"properties":{"___type":{"type":"string","enum":["box"]},"___box":{"type":"object","properties":{"___y1":{"description":"top coordinate of the rectangle","type":"integer"},"___x2":{"description":"right coordinate of the rectangle","type":"integer"},"___x1":{"description":"left coordinate of the rectangle","type":"integer"},"___y2":{"description":"bottom coordinate of the rectangle","type":"integer"}}}}}],"title":"bounding-box with a rectangle"}}]}}},"_88meterOCR":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___v4l2_dev":{"description":"v4l2 device name (e.g. \/dev\/video0). Keep empty if file based image should be used. Has preference over file.","type":"string"},"___impulses":{"default":0,"description":"0 = report absolute values, >0 = report given impulses per unit","type":"integer"},"___rotate":{"default":0,"description":"angle in degree for rotation of the image. Positive angle turn clockwise.","type":"number"},"___protocol":{"type":"string","enum":["ocr"]},"___recognizer":{"type":"array","items":{"oneOf":[{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRRecognizer"},{"properties":{"___type":{"type":"string","enum":["invalid"]}}}],"title":"invalid recognizer. Choose any of the supported ones."}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRRecognizer"},{"properties":{"___type":{"type":"string","enum":["needle"]},"___kernelColorString":{"description":"Color conversion 3x3 matrix. Default red channel only (2 -1 -1 0 0 0 0 0 0). First line channel red. Needles are detected for red color after matrix application. See leptonica:pixMultMatrixColor","type":"string"}}}],"title":"needle type recognizer"}},{"$eref":{"allOf":[{"$ref":"#\/definitions\/meterOCRRecognizer"},{"properties":{"___type":{"type":"string","enum":["binary"]},"___kernelColorString":{"description":"Color conversion 3x3 matrix. Default red channel only (2 -1 -1 0 0 0 0 0 0). First line channel red. Rectangle\/pixes are detected for red color after matrix application. See leptonica:pixMultMatrixColor","type":"string"}}}],"title":"binary (impulses) recognizer"}}]}},"___generate_debug_image":{"default":false,"description":"generate debug images to ease configuration. Will be created in \/run\/vzlogger<nr>_debug.jpg for v4l2 or as <file>_debug.jpg if file based detection is used.","type":"boolean"},"___file":{"default":"\/mnt\/ramdisk\/image.png","description":"filename of the image to be processed (or use v4l2_dev)","type":"string"}}}],"title":"meter extracting data from images (meterOCR)"},"_88meterExec":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___format":{"description":"optional format string. Supports $v for value, $i for identifier and $t for timestamp. E.g. $i:$v. If empty just a value is read from each line of the file.","type":"string"},"___command":{"description":"Command to be executed. Only possible if running as non root. Output will be parsed.","type":"string"},"___protocol":{"type":"string","enum":["exec"]}},"required":["command"]}],"title":"meter extracting data from the output of a shell command\/executable"},"_88meterS0":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___resolution":{"default":1000,"description":"number of impulses per kWh","type":"integer"},"___gpio_dir":{"default":-1,"description":"Number of GPIO port to be used as directional pin. If this pin is used and active Impulses_neg instead of Impulses is returned. Keep to -1 if unsure about the purpose.","type":"integer"},"___mmap":{"default":"","description":"For gpio based devices and high frequency signals (>5-10kHz on a rpi2) memory mapped gpio can be used. Currently only supported on Raspberry-Pi 1 or 2. Leads to a constant but high CPU load depending on nonblocking_delay value. MMAPed GPIO pins need to be configured manually as input pins.","type":"string","enum":["","rpi1","rpi2"]},"___configureGPIO":{"default":true,"description":"If true then vzlogger will export, configure,... the GPIO port. Needs proper access rights to \/sys\/class\/gpio\/.","type":"boolean"},"___send_zero":{"default":false,"description":"If active\/true send data once a second even if no impulses have been received. Use aggregation is this case to reduce frequency.","type":"boolean"},"___protocol":{"type":"string","enum":["s0"]},"___debounce_delay":{"default":30,"description":"Delay in ms until the next edge is detected","type":"integer"},"___gpio":{"default":-1,"description":"Number of GPIO port to be used. If this is set >-1 then device is ignored.","type":"integer"},"___device":{"description":"UART device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___nonblocking_delay":{"default":100000,"description":"Delay in ns for polling\/non-blocking interface. On an rpi2 e.g. 5000 can be used to detect up to 30kHz signals with mmap active.","type":"integer"}},"required":["protocol","device"]}],"title":"S0 based meter"},"_88meterRandom":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___min":{"description":"minimum value (floating point) that will be returned. E.g. 0.0","type":"number"},"___max":{"description":"maximum value (floating point) that will be returned. E.g. 10.0","type":"number"},"___protocol":{"type":"string","enum":["random"]}}}],"title":"example meter returning random values"},"_88push":{"minItems":0,"description":"list of middlewares receiving push data (i.e. non aggregated live data in single http request)","type":"array","items":{"oneOf":[{"$eref":{"type":"object","title":"pushdataentry","properties":{"___url":{"description":"full URL of the middleware to push data to e.g. http:\/\/127.0.0.1\/push\/data.json","type":"string"}},"required":["url"]}}]}},"_88meterOCRRecognizerBinary":{"allOf":[{"$eref":{"type":"object","properties":{"___boundingboxes":{"oneOf":[{"$ref":"#\/definitions\/meterOCRBBInvalid"},{"$ref":"#\/definitions\/meterOCRBBCircle"},{"$ref":"#\/definitions\/meterOCRBBBox"}]}}}},{"properties":{"___type":{"type":"string","enum":["binary"]},"___kernelColorString":{"description":"Color conversion 3x3 matrix. Default red channel only (2 -1 -1 0 0 0 0 0 0). First line channel red. Rectangle\/pixes are detected for red color after matrix application. See leptonica:pixMultMatrixColor","type":"string"}}}],"title":"binary (impulses) recognizer"},"_88meterOCRBBBox":{"allOf":[{"$eref":{"type":"object","properties":{"___digit":{"default":false,"description":"a single digit is expected (thus the recognized value can only be within -9..9)","type":"boolean"},"___scaler":{"default":0,"description":"Scaling factor by 10^<scaler>. E.g. 0 = *1, -1 = *0.1, 2 = *100","type":"integer"},"___identifier":{"description":"id (obis-like) for this reading","type":"string"}}}},{"properties":{"___type":{"type":"string","enum":["box"]},"___box":{"type":"object","properties":{"___y1":{"description":"top coordinate of the rectangle","type":"integer"},"___x2":{"description":"right coordinate of the rectangle","type":"integer"},"___x1":{"description":"left coordinate of the rectangle","type":"integer"},"___y2":{"description":"bottom coordinate of the rectangle","type":"integer"}}}}}],"title":"bounding-box with a rectangle"},"_88meterFluksoV2":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___protocol":{"type":"string","enum":["fluksov2"]},"___fifo":{"default":"\/var\/run\/spid\/delta\/out","description":"fifo to be used.","type":"string"}},"required":["fifo"]}],"title":"fluksov2 meter"},"_88meterOCRBBInvalid":{"allOf":[{"$eref":{"type":"object","properties":{"___digit":{"default":false,"description":"a single digit is expected (thus the recognized value can only be within -9..9)","type":"boolean"},"___scaler":{"default":0,"description":"Scaling factor by 10^<scaler>. E.g. 0 = *1, -1 = *0.1, 2 = *100","type":"integer"},"___identifier":{"description":"id (obis-like) for this reading","type":"string"}}}},{"properties":{"___type":{"type":"string","enum":["invalid"]}}}],"title":"invalid bounding-box. Choose any of the supported ones."},"_88meterFile":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___format":{"description":"optional format string. Supports $v for value, $i for identifier and $t for timestamp. E.g. $i:$v. If empty just a value is read from each line of the file.","type":"string"},"___protocol":{"type":"string","enum":["file"]},"___rewind":{"default":false,"description":"rewind the file handle at each read?","type":"boolean"},"___path":{"description":"file incl. path to be used for data extraction","type":"string"}},"required":["path"]}],"title":"meter extracting data from a given file"},"_88meterOMS":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___mbus_debug":{"default":false,"description":"provide some more debug output on console by calling some libmbus debug functions","type":"boolean"},"___key":{"description":"AES key for the device in hex. Needs to be exactly 32 characters. E.g. 0102030405060708090a0b0c0d0e0f10","type":"string"},"___protocol":{"type":"string","enum":["oms"]},"___device":{"description":"serial device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":9600,"description":"Baudrate to use. Default to 9600.","type":"number"}},"required":["device","key"]}],"title":"OMS \/ OMS (M-Bus) based devices"},"_88meterSML":{"allOf":[{"$eref":{"type":"object","title":"meter","properties":{"___interval":{"default":-1,"description":"delay in secs between queries to the meter","type":"integer"},"___channels":{"$ref":"#\/definitions\/channels"},"___enabled":{"default":false,"description":"enable or disable this meter. Disabled meter will be ignored.","type":"boolean"},"___aggtime":{"default":-1,"description":"aggregate all signals and give one update to middleware every <aggtime> seconds","type":"integer"},"___aggfixedinterval":{"default":false,"description":"round all timestamps to middleware to nearest aggtime","type":"boolean"},"___allowskip":{"default":false,"description":"if enabled, errors when opening meter will lead to meter being ignored","type":"boolean"}},"required":[]}},{"properties":{"___pullseq":{"description":"sequence in hex to send to the meter before each read call","type":"string"},"___parity":{"default":"8n1","description":"parity used for serial communication","type":"string","enum":["8n1","7n1","7e1","7o1"]},"___protocol":{"type":"string","enum":["sml"]},"___device":{"description":"device the meter is connected to. E.g. \/dev\/ttyUSB0","type":"string"},"___baudrate":{"default":9600,"description":"baudrate for serial communication","type":"integer","enum":[50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200,230400]},"___host":{"description":"ip addr of the meter (if not directly connected)","type":"string"}}}],"title":"SML based meter"}},"properties":{"___push":{"$eref":{"minItems":0,"description":"list of middlewares receiving push data (i.e. non aggregated live data in single http request)","type":"array","items":{"oneOf":[{"$ref":"#\/definitions\/pushdataentry"}]}}},"___meters":{"$eref":{"minItems":1,"type":"array","items":{"oneOf":[{"$ref":"#\/definitions\/meterInvalid"},{"$ref":"#\/definitions\/meterS0"},{"$ref":"#\/definitions\/meterD0"},{"$ref":"#\/definitions\/meterSML"},{"$ref":"#\/definitions\/meterRandom"},{"$ref":"#\/definitions\/meterFile"},{"$ref":"#\/definitions\/meterExec"},{"$ref":"#\/definitions\/meterFluksoV2"},{"$ref":"#\/definitions\/meterOCR"},{"$ref":"#\/definitions\/meterOMS"},{"$ref":"#\/definitions\/meterW1therm"}]}}},"___log":{"description":"path to log file","id":"\/log","type":"string"},"___retry":{"description":"How long to sleep between failed requests, in seconds","id":"\/retry","type":"integer"},"___verbosity":{"default":0,"description":"0 = log_error or log-warning, 5 = log_info, 10 = log-debug, 15 = log_finest","id":"\/verbosity","type":"integer","enum":[0,5,10,15]},"___daemon":{"default":"true","description":"Enable daemon mode","id":"\/daemon","type":"boolean"},"___local":{"$eref":{"type":"object","properties":{"___index":{"description":"should we provide a index listing of available channels if no UUID was requested?","id":"\/local\/index","type":"boolean"},"___timeout":{"id":"\/local\/timeout","type":"integer"},"___enabled":{"description":"should we start the local HTTPd for serving live readings?","id":"\/local\/enabled","type":"boolean"},"___port":{"default":8080,"description":"the TCP port for the local HTTPd","id":"\/local\/port","type":"integer"},"___buffer":{"id":"\/local\/buffer","type":"integer"}},"required":["enabled"]}}},"required":["daemon","log"]}