{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"Prometheus configuration file","additionalProperties":false,"title":"Prometheus","type":["object","null"],"definitions":{"_88basic_auth":{"oneOf":[{"required":["password"]},{"required":["password_file"]}],"description":"Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.","additionalProperties":false,"type":["object","null"],"properties":{"___password":{"type":["string","null"]},"___username":{"type":"string"},"___password_file":{"$eref":{"format":"uri-reference","type":["string","null"]}}},"required":["username"]},"_88auth":{"allOf":[{"then":{"properties":{"___bearer_token":{"const":null},"___bearer_token_file":{"const":null}}},"if":{"not":{"properties":{"___basic_auth":{"const":null}}}}},{"then":{"properties":{"___bearer_token_file":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token":{"const":null}}}}},{"then":{"properties":{"___bearer_token":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token_file":{"const":null}}}}}]},"_88static_configs":{"description":"List of labeled statically configured targets for this job.","type":["array","null"],"items":{"type":"object","properties":{"___targets":{"description":"The targets specified by the static config.","type":["array","null"],"items":{"type":"string"}},"___labels":{"$eref":{"patternProperties":{"___^[a-zA-Z_][a-zA-Z0-9_]*$":{"$ref":"#\/definitions\/label_value"}},"additionalProperties":false,"type":["object","null"]},"description":"Labels assigned to all metrics scraped from the targets."}}}},"_88bearer_token_file":{"$eref":{"format":"uri-reference","type":["string","null"]},"description":"Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`."},"_88kubernetes_sd_configs":{"description":"List of Kubernetes service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Kubernetes API.","type":"object"}},"_88bearer_token":{"description":"Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.","type":["string","null"]},"_88ec2_sd_configs":{"description":"List of EC2 service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the EC2 API.","type":"object"}},"_88labels":{"patternProperties":{"___^[a-zA-Z_][a-zA-Z0-9_]*$":{"$eref":{"type":"string"}}},"additionalProperties":false,"type":["object","null"]},"_88azure_sd_configs":{"description":"List of Azure service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Azure API.","type":"object"}},"_88nerve_sd_configs":{"description":"List of AirBnB's Nerve service discovery configurations.","type":["array","null"],"items":{"type":"object"}},"_88duration":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"_88consul_sd_configs":{"description":"List of Consul service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Consul API. It is to be defined as the Consul documentation requires.","type":"object"}},"_88tls_config":{"additionalProperties":false,"type":["object","null"],"properties":{"___insecure_skip_verify":{"description":"Disable validation of the server certificate.","type":["boolean","null"]},"___ca_file":{"$eref":{"format":"uri-reference","type":["string","null"]},"description":"CA certificate to validate API server certificate with."},"___cert_file":{"$eref":{"format":"uri-reference","type":["string","null"]},"description":"Certificate file for client cert authentication to the server."},"___server_name":{"description":"ServerName extension to indicate the name of the server.","type":["string","null"]},"___key_file":{"$eref":{"format":"uri-reference","type":["string","null"]},"description":"Key file for client cert authentication to the server."}}},"_88serverset_sd_configs":{"description":"List of Zookeeper Serverset service discovery configurations.","type":["array","null"],"items":{"type":"object"}},"_88filepath":{"format":"uri-reference","type":["string","null"]},"_88gce_sd_configs":{"description":"List of GCE service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the GCE API.","type":"object"}},"_88scheme":{"type":["string","null"],"enum":["http","https",null]},"_88openstack_sd_configs":{"description":"List of OpenStack service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the OpenStack API.","type":"object"}},"_88file_sd_configs":{"description":"List of file service discovery configurations.","type":["array","null"],"items":{"type":"object","properties":{"___files":{"minItems":1,"description":"Patterns for files from which target groups are extracted. Where the pattern may be a path ending in .json, .yml or .yaml. The last path segment may contain a single * that matches any character sequence, e.g. my\/path\/tg_*.json.","type":"array","items":{"type":"string"}},"___refresh_interval":{"default":"5m","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Refresh interval to re-read the files."}}}},"_88marathon_sd_configs":{"description":"List of Marathon service discovery configurations.","type":["array","null"],"items":{"type":"object"}},"_88relabel_configs":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$eref":{"pattern":"^[a-zA-Z_][a-zA-Z0-9_]*$","type":"string"}}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}},"_88label_value":{"type":"string"},"_88filepath_glob":{"type":"string"},"_88label_name":{"pattern":"^[a-zA-Z_][a-zA-Z0-9_]*$","type":"string"},"_88dns_sd_configs":{"description":"List of DNS service discovery configurations.","type":["array","null"],"items":{"description":"A DNS-based service discovery configuration allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from \/etc\/resolv.conf. This service discovery method only supports basic DNS A, AAAA and SRV record queries, but not the advanced DNS-SD approach specified in RFC6763. During the relabeling phase, the meta label __meta_dns_name is available on each target and is set to the record name that produced the discovered target.","type":"object"}},"_88triton_sd_configs":{"description":"List of Triton service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Triton discovery API.","type":"object"}}},"properties":{"___rule_files":{"description":"Rule files specifies a list of globs. Rules and alerts are read from all matching files.","type":["array","null"],"items":{"$eref":{"type":"string"}}},"___alerting":{"description":"Alerting specifies settings related to the Alertmanager.","type":["object","null"],"properties":{"___alert_relabel_configs":{"$eref":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$ref":"#\/definitions\/label_name"}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}}},"___alertmanagers":{"type":["array","null"],"items":{"allOf":[{"$eref":{"allOf":[{"then":{"properties":{"___bearer_token":{"const":null},"___bearer_token_file":{"const":null}}},"if":{"not":{"properties":{"___basic_auth":{"const":null}}}}},{"then":{"properties":{"___bearer_token_file":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token":{"const":null}}}}},{"then":{"properties":{"___bearer_token":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token_file":{"const":null}}}}}]}}],"type":"object","properties":{"___ec2_sd_configs":{"$eref":{"description":"List of EC2 service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the EC2 API.","type":"object"}}},"___static_configs":{"$eref":{"description":"List of labeled statically configured targets for this job.","type":["array","null"],"items":{"type":"object","properties":{"___targets":{"description":"The targets specified by the static config.","type":["array","null"],"items":{"type":"string"}},"___labels":{"description":"Labels assigned to all metrics scraped from the targets.","$ref":"#\/definitions\/labels"}}}}},"___file_sd_configs":{"$eref":{"description":"List of file service discovery configurations.","type":["array","null"],"items":{"type":"object","properties":{"___files":{"minItems":1,"description":"Patterns for files from which target groups are extracted. Where the pattern may be a path ending in .json, .yml or .yaml. The last path segment may contain a single * that matches any character sequence, e.g. my\/path\/tg_*.json.","type":"array","items":{"type":"string"}},"___refresh_interval":{"default":"5m","description":"Refresh interval to re-read the files.","$ref":"#\/definitions\/duration"}}}}},"___scheme":{"$eref":{"type":["string","null"],"enum":["http","https",null]},"description":"Configures the protocol scheme used for requests."},"___tls_config":{"$eref":{"additionalProperties":false,"type":["object","null"],"properties":{"___insecure_skip_verify":{"description":"Disable validation of the server certificate.","type":["boolean","null"]},"___ca_file":{"description":"CA certificate to validate API server certificate with.","$ref":"#\/definitions\/filepath"},"___cert_file":{"description":"Certificate file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"},"___server_name":{"description":"ServerName extension to indicate the name of the server.","type":["string","null"]},"___key_file":{"description":"Key file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"}}},"description":"Configures the scrape request's TLS settings."},"___serverset_sd_configs":{"$eref":{"description":"List of Zookeeper Serverset service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___timeout":{"default":"10s","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Per-target Alertmanager timeout when pushing alerts."},"___bearer_token":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.","type":["string","null"]}},"___relabel_configs":{"$eref":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$ref":"#\/definitions\/label_name"}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}},"description":"List of target relabel configurations."},"___consul_sd_configs":{"$eref":{"description":"List of Consul service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Consul API. It is to be defined as the Consul documentation requires.","type":"object"}}},"___nerve_sd_configs":{"$eref":{"description":"List of AirBnB's Nerve service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___api_version":{"default":"v1","description":"The api version of Alertmanager.","type":["string","null"]},"___proxy_url":{"format":"uri-reference","description":"Optional proxy URL.","type":["string","null"]},"___triton_sd_configs":{"$eref":{"description":"List of Triton service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Triton discovery API.","type":"object"}}},"___path_prefix":{"default":"\/","description":"Prefix for the HTTP path alerts are pushed to.","type":["string","null"]},"___azure_sd_configs":{"$eref":{"description":"List of Azure service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Azure API.","type":"object"}}},"___dns_sd_configs":{"$eref":{"description":"List of DNS service discovery configurations.","type":["array","null"],"items":{"description":"A DNS-based service discovery configuration allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from \/etc\/resolv.conf. This service discovery method only supports basic DNS A, AAAA and SRV record queries, but not the advanced DNS-SD approach specified in RFC6763. During the relabeling phase, the meta label __meta_dns_name is available on each target and is set to the record name that produced the discovered target.","type":"object"}}},"___gce_sd_configs":{"$eref":{"description":"List of GCE service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the GCE API.","type":"object"}}},"___bearer_token_file":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`.","$ref":"#\/definitions\/filepath"}},"___basic_auth":{"$eref":{"oneOf":[{"required":["password"]},{"required":["password_file"]}],"description":"Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.","additionalProperties":false,"type":["object","null"],"properties":{"___password":{"type":["string","null"]},"___username":{"type":"string"},"___password_file":{"$ref":"#\/definitions\/filepath"}},"required":["username"]}},"___marathon_sd_configs":{"$eref":{"description":"List of Marathon service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___kubernetes_sd_configs":{"$eref":{"description":"List of Kubernetes service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Kubernetes API.","type":"object"}}}}}}}},"___remote_write":{"description":"Settings related to the remote write feature.","type":["array","null"],"items":{"allOf":[{"$eref":{"allOf":[{"then":{"properties":{"___bearer_token":{"const":null},"___bearer_token_file":{"const":null}}},"if":{"not":{"properties":{"___basic_auth":{"const":null}}}}},{"then":{"properties":{"___bearer_token_file":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token":{"const":null}}}}},{"then":{"properties":{"___bearer_token":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token_file":{"const":null}}}}}]}}],"additionalProperties":false,"type":"object","properties":{"___queue_config":{"description":"Configures the queue used to write to remote storage.","type":["object","null"],"properties":{"___max_shards":{"default":1000,"description":"Maximum number of shards, i.e. amount of concurrency.","type":["integer","null"]},"___max_samples_per_send":{"default":100,"description":"Maximum number of samples per send.","type":["integer","null"]},"___capacity":{"default":500,"description":"Number of samples to buffer per shard before we block reading of more samples from the WAL. It is recommended to have enough capacity in each shard to buffer several requests to keep throughput up while processing occasional slow remote requests.","type":["integer","null"]},"___max_backoff":{"default":"100ms","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Maximum retry delay."},"___min_backoff":{"default":"30ms","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Initial retry delay. Gets doubled for every retry."},"___min_shards":{"default":1,"description":"Minimum number of shards, i.e. amount of concurrency.","type":["integer","null"]},"___batch_send_deadline":{"default":"5s","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Maximum time a sample will wait in buffer."}}},"___tls_config":{"$eref":{"additionalProperties":false,"type":["object","null"],"properties":{"___insecure_skip_verify":{"description":"Disable validation of the server certificate.","type":["boolean","null"]},"___ca_file":{"description":"CA certificate to validate API server certificate with.","$ref":"#\/definitions\/filepath"},"___cert_file":{"description":"Certificate file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"},"___server_name":{"description":"ServerName extension to indicate the name of the server.","type":["string","null"]},"___key_file":{"description":"Key file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"}}},"description":"Configures the remote write request's TLS settings."},"___url":{"format":"uri-reference","description":"The URL of the endpoint to send samples to.","type":"string"},"___bearer_token":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.","type":["string","null"]}},"___remote_timeout":{"default":"30s","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Timeout for requests to the remote write endpoint."},"___bearer_token_file":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`.","$ref":"#\/definitions\/filepath"}},"___basic_auth":{"$eref":{"oneOf":[{"required":["password"]},{"required":["password_file"]}],"description":"Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.","additionalProperties":false,"type":["object","null"],"properties":{"___password":{"type":["string","null"]},"___username":{"type":"string"},"___password_file":{"$ref":"#\/definitions\/filepath"}},"required":["username"]}},"___proxy_url":{"format":"uri-reference","description":"Optional proxy URL.","type":["string","null"]},"___write_relabel_configs":{"$eref":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$ref":"#\/definitions\/label_name"}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}},"description":"List of remote write relabel configurations."}},"required":["url"]}},"___scrape_configs":{"description":"A list of scrape configurations.","type":["array","null"],"items":{"allOf":[{"$eref":{"allOf":[{"then":{"properties":{"___bearer_token":{"const":null},"___bearer_token_file":{"const":null}}},"if":{"not":{"properties":{"___basic_auth":{"const":null}}}}},{"then":{"properties":{"___bearer_token_file":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token":{"const":null}}}}},{"then":{"properties":{"___bearer_token":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token_file":{"const":null}}}}}]}}],"additionalProperties":false,"type":"object","properties":{"___ec2_sd_configs":{"$eref":{"description":"List of EC2 service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the EC2 API.","type":"object"}}},"___static_configs":{"$eref":{"description":"List of labeled statically configured targets for this job.","type":["array","null"],"items":{"type":"object","properties":{"___targets":{"description":"The targets specified by the static config.","type":["array","null"],"items":{"type":"string"}},"___labels":{"description":"Labels assigned to all metrics scraped from the targets.","$ref":"#\/definitions\/labels"}}}}},"___metric_relabel_configs":{"$eref":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$ref":"#\/definitions\/label_name"}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}},"description":"List of metric relabel configurations."},"___params":{"description":"Optional HTTP(S) URL parameters.","additionalProperties":{"type":"string"},"type":["object","null"]},"___relabel_configs":{"$eref":{"type":["array","null"],"items":{"then":{"required":["target_label"]},"type":"object","if":{"properties":{"___action":{"const":"replace"}}},"properties":{"___action":{"default":"replace","description":"Action to perform based on regex matching.","type":"string","enum":["replace","keep","drop","hashmod","labelmap","labeldrop","labelkeep"]},"___source_labels":{"description":"The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.","type":"array","items":{"$ref":"#\/definitions\/label_name"}},"___separator":{"default":";","description":"Separator placed between concatenated source label values.","type":"string"},"___modulus":{"description":"Modulus to take of the hash of the source label values.","type":"integer"},"___target_label":{"description":"Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L146 has a regex capture group, violating vanilla label_name definition.","type":"string"},"___regex":{"default":"(.*)","description":"Regular expression against which the extracted value is matched.","$comment":"https:\/\/github.com\/prometheus\/prometheus\/blob\/release-2.13\/config\/testdata\/conf.good.yml#L111 has integer instead of string"},"___replacement":{"default":"$1","description":"Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available.","type":"string"}}}},"description":"List of target relabel configurations."},"___consul_sd_configs":{"$eref":{"description":"List of Consul service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Consul API. It is to be defined as the Consul documentation requires.","type":"object"}}},"___proxy_url":{"format":"uri-reference","description":"Optional proxy URL.","type":["string","null"]},"___scrape_timeout":{"$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Per-scrape timeout when scraping this job. Defaults to `global.scrape_timeout`."},"___azure_sd_configs":{"$eref":{"description":"List of Azure service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Azure API.","type":"object"}}},"___gce_sd_configs":{"$eref":{"description":"List of GCE service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the GCE API.","type":"object"}}},"___bearer_token_file":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`.","$ref":"#\/definitions\/filepath"}},"___honor_labels":{"default":false,"description":"Controls how Prometheus handles conflicts between labels that are already present in scraped data and labels that Prometheus would attach server-side (\"job\" and \"instance\" labels, manually configured target labels, and labels generated by service discovery implementations).","type":["boolean","null"]},"___marathon_sd_configs":{"$eref":{"description":"List of Marathon service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___file_sd_configs":{"$eref":{"description":"List of file service discovery configurations.","type":["array","null"],"items":{"type":"object","properties":{"___files":{"minItems":1,"description":"Patterns for files from which target groups are extracted. Where the pattern may be a path ending in .json, .yml or .yaml. The last path segment may contain a single * that matches any character sequence, e.g. my\/path\/tg_*.json.","type":"array","items":{"type":"string"}},"___refresh_interval":{"default":"5m","description":"Refresh interval to re-read the files.","$ref":"#\/definitions\/duration"}}}}},"___scheme":{"$eref":{"type":["string","null"],"enum":["http","https",null]},"description":"Configures the protocol scheme used for requests."},"___tls_config":{"$eref":{"additionalProperties":false,"type":["object","null"],"properties":{"___insecure_skip_verify":{"description":"Disable validation of the server certificate.","type":["boolean","null"]},"___ca_file":{"description":"CA certificate to validate API server certificate with.","$ref":"#\/definitions\/filepath"},"___cert_file":{"description":"Certificate file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"},"___server_name":{"description":"ServerName extension to indicate the name of the server.","type":["string","null"]},"___key_file":{"description":"Key file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"}}},"description":"Configures the scrape request's TLS settings."},"___serverset_sd_configs":{"$eref":{"description":"List of Zookeeper Serverset service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___bearer_token":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.","type":["string","null"]}},"___scrape_interval":{"$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"How frequently to scrape targets from this job. Defaults to `global.scrape_interval`."},"___metrics_path":{"default":"\/metrics","description":"The HTTP resource path on which to fetch metrics from targets.","type":["string","null"]},"___nerve_sd_configs":{"$eref":{"description":"List of AirBnB's Nerve service discovery configurations.","type":["array","null"],"items":{"type":"object"}}},"___openstack_sd_configs":{"$eref":{"description":"List of OpenStack service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the OpenStack API.","type":"object"}}},"___triton_sd_configs":{"$eref":{"description":"List of Triton service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Triton discovery API.","type":"object"}}},"___honor_timestamps":{"default":true,"description":"Controls whether Prometheus respects the timestamps present in scraped data.","type":["boolean","null"]},"___job_name":{"description":"The job name assigned to scraped metrics by default. Must be unique across all scrape configurations.","type":"string"},"___dns_sd_configs":{"$eref":{"description":"List of DNS service discovery configurations.","type":["array","null"],"items":{"description":"A DNS-based service discovery configuration allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from \/etc\/resolv.conf. This service discovery method only supports basic DNS A, AAAA and SRV record queries, but not the advanced DNS-SD approach specified in RFC6763. During the relabeling phase, the meta label __meta_dns_name is available on each target and is set to the record name that produced the discovered target.","type":"object"}}},"___basic_auth":{"$eref":{"oneOf":[{"required":["password"]},{"required":["password_file"]}],"description":"Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.","additionalProperties":false,"type":["object","null"],"properties":{"___password":{"type":["string","null"]},"___username":{"type":"string"},"___password_file":{"$ref":"#\/definitions\/filepath"}},"required":["username"]}},"___sample_limit":{"default":0,"description":"Per-scrape limit on number of scraped samples that will be accepted. If more than this number of samples are present after metric relabelling the entire scrape will be treated as failed. 0 means no limit.","type":["integer","null"]},"___kubernetes_sd_configs":{"$eref":{"description":"List of Kubernetes service discovery configurations.","type":["array","null"],"items":{"description":"The information to access the Kubernetes API.","type":"object"}}}},"required":["job_name"]}},"___remote_read":{"description":"Settings related to the remote read feature.","type":["array","null"],"items":{"allOf":[{"$eref":{"allOf":[{"then":{"properties":{"___bearer_token":{"const":null},"___bearer_token_file":{"const":null}}},"if":{"not":{"properties":{"___basic_auth":{"const":null}}}}},{"then":{"properties":{"___bearer_token_file":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token":{"const":null}}}}},{"then":{"properties":{"___bearer_token":{"const":null},"___basic_auth":{"const":null}}},"if":{"not":{"properties":{"___bearer_token_file":{"const":null}}}}}]}}],"additionalProperties":false,"type":"object","properties":{"___read_recent":{"default":false,"description":"Whether reads should be made for queries for time ranges that the local storage should have complete data for.","type":["boolean","null"]},"___required_matchers":{"$eref":{"patternProperties":{"___^[a-zA-Z_][a-zA-Z0-9_]*$":{"$ref":"#\/definitions\/label_value"}},"additionalProperties":false,"type":["object","null"]},"description":"An optional list of equality matchers which have to be present in a selector to query the remote read endpoint."},"___tls_config":{"$eref":{"additionalProperties":false,"type":["object","null"],"properties":{"___insecure_skip_verify":{"description":"Disable validation of the server certificate.","type":["boolean","null"]},"___ca_file":{"description":"CA certificate to validate API server certificate with.","$ref":"#\/definitions\/filepath"},"___cert_file":{"description":"Certificate file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"},"___server_name":{"description":"ServerName extension to indicate the name of the server.","type":["string","null"]},"___key_file":{"description":"Key file for client cert authentication to the server.","$ref":"#\/definitions\/filepath"}}}},"___url":{"format":"uri-reference","description":"The URL of the endpoint to query from.","type":"string"},"___bearer_token":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the configured bearer token. It is mutually exclusive with `bearer_token_file`.","type":["string","null"]}},"___remote_timeout":{"default":"1m","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"Timeout for requests to the remote read endpoint."},"___bearer_token_file":{"$eref":{"description":"Sets the `Authorization` header on every scrape request with the bearer token read from the configured file. It is mutually exclusive with `bearer_token`.","$ref":"#\/definitions\/filepath"}},"___basic_auth":{"$eref":{"oneOf":[{"required":["password"]},{"required":["password_file"]}],"description":"Sets the `Authorization` header on every remote write request with the configured username and password. password and password_file are mutually exclusive.","additionalProperties":false,"type":["object","null"],"properties":{"___password":{"type":["string","null"]},"___username":{"type":"string"},"___password_file":{"$ref":"#\/definitions\/filepath"}},"required":["username"]}},"___proxy_url":{"format":"uri-reference","description":"Optional proxy URL.","type":["string","null"]}},"required":["url"]}},"___global":{"description":"The global configuration specifies parameters that are valid in all other configuration contexts. They also serve as defaults for other configuration sections.","additionalProperties":false,"type":["object","null"],"properties":{"___evaluation_interval":{"default":"1m","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"How frequently to evaluate rules."},"___scrape_timeout":{"default":"10s","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"How long until a scrape request times out."},"___scrape_interval":{"default":"1m","$eref":{"pattern":"^[0-9]+(ms|[smhdwy])$","type":["string","null"]},"description":"How frequently to scrape targets by default."},"___external_labels":{"$eref":{"patternProperties":{"___^[a-zA-Z_][a-zA-Z0-9_]*$":{"$ref":"#\/definitions\/label_value"}},"additionalProperties":false,"type":["object","null"]},"description":"The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager)."}}}},"$id":"http:\/\/json.schemastore.org\/prometheus"}